/*
*  一 . 三次握手的过程
*   1 由客户端发起一个带有 SYN = 1， Seq = X 的数据包，告诉服务器我要发送请求了，你做好准备
*   2 服务端发回一个带有 SYN = 1， ACK = X + 1，Seq = Y 的响应包以示传达确认信息
*   告诉浏览器，我准备接收了，你可以发送了
*   3 客户端回传一个带有 ACK = Y + 1, Seq = Z 的数据包，代表握手结束
*   告诉服务器 我马上就发了，你准备接收吧
*
* 为什么是三次而不是两次
*   如果只有两次，在服务端接收SYN包后，给客户端发送一个 ACK确认包后就进入 establish状态，万一这个请求中间遇到网络情况而没有传给客户端，
* 客户端一直处于等待状态，也就接收不到信息
*
*  二 . 四次挥手
*    数据传送完毕，需要断开tcp连接，需要四次挥手
*     1 发起方向被动方发送报文，Fin，Ack，Seq，表示已经没有数据传送了，并进入 Fin_Wait_1状态
*       客户端告诉服务器数据发送完了，你准备关闭吧
*     2 被动方发送报文，Ack，Seq 表示同意关闭请求，此时发起方处于 Fin_Wait_2状态
*       服务器告诉浏览器我接收完了 准备关闭了， 你也准备吧
*     3 被动方向发起方发送报文段， Fin，Ack，Seq请求关闭连接，并进入 Last_Ack状态
*       服务器发起，告诉浏览器我响应报文发送完了，你准备关闭吧
*     4 发起方向被动方发送报文段，Ack，Seq，然后进入等待 Time_Wait状态，被动方收到发起方的报文段后关闭连接。
* 发起方等待一段时间未收到回复，则正常关闭，
*
* 为什么要等待一段时间？
*   因为最后服务端发送的ACK包可能会丢失，如果不等待两个周期的话，服务端会在收到ACK包之前不停的重复发送Fin包而不关闭
* */

/*
http 和 https
  http 超文本传输协议
  被用于在web浏览器和网站服务器之间传递信息
  以明文方式发送内容，不提供任何形式的数据加密，攻击者如果截取了传输报文，就可以直接获取其中的信息
  https 安全套接字超文本传输协议
  在http的基础上加入了 SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器之间的通信加密
  https的主要作用：
    建立一个信息传输的安全通道，确认网站的真实性
 两者的主要区别：
  1. https需要到ca申请证书，需要一定的费用
  2. 两者的连接方式完全不同，用的端口也不一样，前者是80，后者是443
  3. http协议是很简单，无状态的协议，https是SSL/TLS + http协议构建的可加密传输，身份认证的网络协议
*
* */

/*
*  客户端在利用https和服务器通信时的步骤
* 1. 客户使用 https的 URL访问web服务器，要求与web服务器建立SSL连接
* 2. web服务器收到客户端请求之后，会将网站的证书信息传送一份给客户端
* 3. 浏览器和服务器开始协商 SSL/TLS 连接的安全等级，也就是信息加密的等级
* 4. 浏览器根据安全等级建立会话密钥，公钥加密
* 5. web服务器私钥解密
* 6. web服务器利用会话密钥加密与客户端之间的通信
*
* */


/*
http 1.0, 1.1, 2.0 的区别
  1. 缓存处理
    1.0主要使用 header里的 if-modified-since，expires来作为缓存判断的标准，1.1则引入了更多的缓存控制策略，如 entity tag，
    if-unmodified-since， if-match， if-none-match等可供选择的缓存头来控制缓存策略
  2. 带宽优化及网络链接的使用
    1.0 中存在带宽浪费的现象，如客户端只需要某个对象的一部分，服务器却将整个对象送过来，并且不支持断点续传，
    1.1 则在请求头引入了 range头域，允许只请求资源的某个部分，即返回码是 206
  3. 错误通知的处理
    1.1中新增了24个错误状态响应码，如 409表示请求的资源与资源的当前状态发生冲突，410表示服务器上的某个资源被永久删除
  4. host头处理
    1.0中认为每台服务器绑定唯一的 ip地址，因此请求的url中没有主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，
    共享一个ip地址， 1.1的请求消息和响应消息都支持 host头域，且在请求消息中如果没有host头域会报 400错误（Bed Request）
  5. 长连接
    1.1支持长连接和请求的流水线处理，在一个tcp连接上可以传送多个http请求和响应，减少了建立和关闭连接的消耗和延迟，
    1.1中默认开启了 connection： keep-alive，一定程度上弥补了1.0每次请求都要建立连接的缺点。
    局限性是 服务器只有处理完上一个请求才会处理下一个请求，如果前一个请求很慢，就会造成队头阻塞

 http2.0
    1. 新的二进制格式
      1.x的解析是基于文本，基于文本格式的解析存在天然缺陷。2.0 采用二进制，实现方便且健壮
    2. 多路复用
      即连接共享，每个request都是用作连接共享机制的，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机
      的混杂在一起，接收方可以根据request的id将request再归属到不同的服务端请求里面
    3. header压缩
      1.x的header携带大量信息，每次请求都会重复发送。 2.0使用encoder来减少需要传输的 header大小，通信双方各自cache一份 header fields表
      既避免了重复header的传输，又减小了需要传输的大小
    4. 服务端推送
      允许服务器未经请求，主动向客户端发送它认为客户端需要的资源到缓存中，以此来避免往返的延迟


* */
